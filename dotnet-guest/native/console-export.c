#include <stdlib.h>
#include <string.h>
#include <sys/time.h>

#include "./console.h"

#include <mono-wasi/driver.h>
#include <mono/metadata/assembly.h>
#include <mono/metadata/class.h>
#include <mono/metadata/appdomain.h>
#include <mono/metadata/image.h>
#include <mono/metadata/metadata.h>
#include <mono/metadata/object.h>
#include <mono/metadata/debug-helpers.h>
#include <mono/metadata/reflection.h>
#include <mono/utils/mono-publib.h>

#include "./host-components.h"
#include "./util.h"

// These are generated by the WASI SDK during build
const char* dotnet_wasi_getentrypointassemblyname();
const char* dotnet_wasi_getbundledfile(const char* name, int* out_length);
void dotnet_wasi_registerbundledassemblies();

MonoObject* call_clr_request_handler(MonoMethod* handler, console_string_t* req, MonoObject** exn) {
    *exn = NULL;

    void *params[1];
    params[0] = req;
    return mono_wasm_invoke_method(handler, NULL, params, exn);
}

console_string_t internal_error(const char* message) {
    console_string_t response;
    response.ptr = (char*)message;
    response.len = strlen(message);
    return response;
}

unsigned long time_microseconds() {
    struct timeval tv;
    gettimeofday(&tv, NULL);
    return 1000000 * tv.tv_sec + tv.tv_usec;
}

// This is a C runtime internal: calling it is a bit of a desperate kludge.
//
// The call to __wasm_call_ctors is needed to set up the Wasm end of the preopened directories
// (and environment variables? TBC). It's normally emitted by the compiler as part of C runtime startup.
// But at the moment it is emitted only at the main() entry point. It's not clear how to get it
// emitted for component model entry points. `-Wl,--no-entry -mexec-model=reactor` might do it
// according to https://github.com/WebAssembly/wasi-sdk/issues/110; we should test this and, if it
// works, discuss ways to get it incorporated as a build option for the .NET WASI SDK.
void __wasm_call_ctors();

// If wizer is run on this module, these fields will be populated at build time and hence we'll be able
// to skip loading and initializing the runtime on a per-request basis. But if wizer isn't run, we'll
// set up the runtime separately for each request.

const char* initialization_error;
MonoMethod* http_handler;
MonoObject* http_handler_attr;
int preinitialized;

void process_handle_console_input(console_string_t *req, console_string_t *ret0) {
    MonoObject* exn;
    MonoObject* call_result = call_clr_request_handler(http_handler, req, &exn);
    
    if (exn) {
        MonoString* exn_str = mono_object_to_string(exn, NULL);
        char* exn_cstr = mono_wasm_string_get_utf8(exn_str);
        *ret0 = internal_error(exn_cstr);
        return;
    }

    console_string_t* resp = mono_object_unbox(call_result);
    *ret0 = *resp;
}

void initialize() {
    dotnet_wasi_registerbundledassemblies();
    mono_wasm_load_runtime("", 0);
    attach_internal_calls();

    entry_points_err_t entry_points_err = find_entry_points("WasmDayDotnet.ConsoleHandlerAttribute", &http_handler_attr, &http_handler);
    if (entry_points_err) {
        if (entry_points_err == EP_ERR_NO_HANDLER_METHOD) {
            initialization_error = "Assembly does not contain a method with ConsoleHandlerAttribute";
        } else {
            initialization_error = "Internal error loading console handler";
        }
        return;
    }
}

__attribute__((export_name("wizer.initialize")))
void preinitialize() {
    preinitialized = 1;
    initialize();
}

void console_handle_console_input(console_string_t *req, console_string_t *ret0) {
    __wasm_call_ctors();

    if (!preinitialized) {
        initialize();
    }
    if (initialization_error) {
        *ret0 = internal_error(initialization_error);
        return;
    }

    process_handle_console_input(req, ret0);
}
